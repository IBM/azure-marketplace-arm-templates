---
- name: Install IBM watsonx.ai
  hosts: localhost
  gather_facts: false

  vars:
    ansible_python_interpreter: "/usr/bin/python3"
    log_level: "info"
    odf:
      license: "decline"
      cluster_size: "1Ti"
      existing_nodes: "no"
    directories:
      bin_dir: "/usr/local/bin"
      tmp_dir: "/tmp"
    default:
      retries: 60
      retry_delay: 15

  tasks:

    - name: Check if oc client is already installed
      ansible.builtin.stat:
        path: "{{ directories.bin_dir }}/oc"
      register: oc_file

    - name: Install oc client if not already installed
      ansible.builtin.include_tasks:
        file: install-oc.yaml
      when: not oc_file.stat.exists

    - name: Check if already logged into cluster
      ansible.builtin.shell: |
        set timeout 30
        {{ directories.bin_dir }}/oc status 2> /dev/null
        exit 0
      args:
        executable: /bin/bash
      register: response

    - name: Login to OpenShift cluster if not already logged in
      ansible.builtin.include_tasks:
        file: ./oc-login.yaml
      when: response.stdout == ""

    - name: Create template directory if not already in place
      ansible.builtin.file:
        path: ./templates
        state: directory
      
    # Following is required as some implementations download templates and playbooks to a single directory
    - name: Copy templates to template directory
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: ./templates/
      with_fileglob:
        - ./*.j2

    - name: Wait for cluster to be available
      ansible.builtin.shell: |
        set timeout 900
        {{ directories.bin_dir }}oc adm wait-for-stable-cluster
        exit 0
      args:
        executable: /bin/bash

    - name: Get the cluster id
      ansible.builtin.shell:
        cmd: "{{ directories.bin_dir }}/oc get -o jsonpath='{.status.infrastructureName}{\"\\n\"}' infrastructure cluster"
      register: response

    - name: Set the cluster id fact
      ansible.builtin.set_fact:
        cluster_id: "{{ response.stdout }}"

    - name: Output the cluster id
      ansible.builtin.debug:
        msg: "Cluster id is {{ cluster_id }}"
      when: log_level == "debug"

    - name: Get the openshift version
      ansible.builtin.shell:
        cmd: "{{ directories.bin_dir }}/oc version -o json | jq -r '.openshiftVersion' | awk '{split($0,version,\".\"); print version[1],version[2]}' | sed 's/ /./g'"
      register: response

    - name: Set the openshift version fact
      ansible.builtin.set_fact:
        openshift_version: "{{ response.stdout }}"

    - name: Output the openshift version
      ansible.builtin.debug:
        msg: "OpenShift version is {{ openshift_version }}"
      when: log_level == "debug"

    - name: Get the first machineset
      ansible.builtin.shell: 
        cmd: "{{ directories.bin_dir }}/oc get machinesets -A | grep openshift-machine-api | head -n 1 | awk '{print $2}'"
      register: response
    
    - name: Set the machineset fact
      ansible.builtin.set_fact:
        first_machineset: "{{ response.stdout }}"

    - name: Output the first machineset
      ansible.builtin.debug:
        msg: "First machineset is {{ first_machineset }}"
      when: log_level == "debug"

    - name: Get the cluster location from the first machineset
      ansible.builtin.shell:
        cmd: "{{ directories.bin_dir }}/oc get machineset/{{ first_machineset }} -n openshift-machine-api -o jsonpath='{.spec.template.spec.providerSpec.value.location}{\"\\n\"}'"
      register: response

    - name: Set the location fact
      ansible.builtin.set_fact:
        cluster_location: "{{ response.stdout }}"

    - name: Output the cluster location
      ansible.builtin.debug:
        msg: "Cluster location is {{ cluster_location }}"
      when: log_level == "debug"